<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Automatic CSV to SQL ETL in Clojure &#8211; Art is Never Finished</title>
<meta name="description" content="This is another basic example to help beginners get started in Clojure, which is still my favorite programming language, almost 10 years after I first started using it. Like all languages, Clojure has some warts. But it also has a lot of very powerful and abstract concepts that many average programmers have not seen before, and like most mathematical concepts, the power of such abstractions are greatly underestimated by many people. Even fancy-sounding but easy-to-understand concepts like homoiconicity are still really underappreciated in the programming community.

">
<meta name="keywords" content="clojure">


<!-- Twitter Cards -->
<meta name="twitter:title" content="Automatic CSV to SQL ETL in Clojure">
<meta name="twitter:description" content="This is another basic example to help beginners get started in Clojure, which is still my favorite programming language, almost 10 years after I first started using it. Like all languages, Clojure has some warts. But it also has a lot of very powerful and abstract concepts that many average programmers have not seen before, and like most mathematical concepts, the power of such abstractions are greatly underestimated by many people. Even fancy-sounding but easy-to-understand concepts like homoiconicity are still really underappreciated in the programming community.

">
<meta name="twitter:site" content="@ivarthorson">
<meta name="twitter:creator" content="@ivarthorson">

<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/images/">

<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Automatic CSV to SQL ETL in Clojure">
<meta property="og:description" content="This is another basic example to help beginners get started in Clojure, which is still my favorite programming language, almost 10 years after I first started using it. Like all languages, Clojure has some warts. But it also has a lot of very powerful and abstract concepts that many average programmers have not seen before, and like most mathematical concepts, the power of such abstractions are greatly underestimated by many people. Even fancy-sounding but easy-to-understand concepts like homoiconicity are still really underappreciated in the programming community.

">
<meta property="og:url" content="/blog/csv-etl-in-clojure/">
<meta property="og:site_name" content="Art is Never Finished">





<link rel="canonical" href="/blog/csv-etl-in-clojure/">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Art is Never Finished Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<!-- Webfonts -->
<script src="https://use.edgefonts.net/source-sans-pro:n2,i2,n3,i3,n4,i4,n6,i6,n7,i7,n9,i9;source-code-pro:n4,n7;volkhov.js"></script>

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
  <script src="/assets/js/vendor/html5shiv.min.js"></script>
  <script src="/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>


<!-- MathJax -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body id="post">

<div class="navigation-wrapper">
	<nav role="navigation" id="site-nav" class="animated drop">
	    <ul>
      
		    
		    <li><a href="/about/" >About</a></li>
		  
		    
		    <li><a href="/blog/" >Blog</a></li>
		  
		    
		    <li><a href="/project-euler/" >Code</a></li>
		  
		    
		    <li><a href="/search/" >Search</a></li>
		  
		    
		    <li><a href="/tags/" >Tags</a></li>
		  
	    </ul>
	</nav>
</div><!-- /.navigation-wrapper -->

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->

<header class="masthead">
	<div class="wrap">
      
      <h1 class="site-title animated fadeIn"><a href="/">Art is Never Finished</a></h1>
		<h2 class="site-description animated fadeIn" itemprop="description">...Only Abandoned. – Leonardo da Vinci</h2>
	</div>
</header><!-- /.masthead -->

<div class="js-menu-screen menu-screen"></div>


<div id="main" role="main">
  <article class="hentry">
    
    <div class="entry-wrapper">
      <header class="entry-header">
        <ul class="entry-tags">
          <li><a href="/tags/#clojure" title="Pages tagged clojure">clojure</a></li>
        </ul>
        
          <h1 class="entry-title">Automatic CSV to SQL ETL in Clojure</h1>
        
      </header>
      <footer class="entry-meta">
        
        
          <img src="/images/ivar.jpg" class="bio-photo" alt="Ivar Thorson bio photo"></a>
        
        <span class="author vcard">By <span class="fn">Ivar Thorson</span></span>
        <span class="entry-date date published"><time datetime="2019-03-03T00:00:00-08:00"><i class="fa fa-calendar-o"></i> March 03, 2019</time></span>
        
        
        
        
      </footer>
      <div class="entry-content">
        <p>This is another basic example to help beginners get started in <a href="https://clojure.org">Clojure</a>, which is still my favorite programming language, almost 10 years after I first started using it. Like all languages, Clojure has some warts. But it also has a lot of very powerful and abstract concepts that many average programmers have not seen before, and like most mathematical concepts, the power of such abstractions are greatly underestimated by many people. Even fancy-sounding but easy-to-understand concepts like <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a> are still really underappreciated in the programming community.</p>

<p>Compared with other mathematically-oriented languages like Haskell, Clojure is also arguably a more practical choice for practical tasks – it’s designed for massive concurrency, and has more libraries than any other language. This is a bold but probably a true statement because, in addition to its own libraries, Clojure can use java libraries on the back-end and javascript libraries on the front-end, which are two of the most popular languages in existence.</p>

<h2 id="tl-dr">TL; DR</h2>

<p>In this article, I’ll present a simple example of setting up a SQL database from a bunch of CSV files. This is called an ETL job (Extract, Transfer, Load), which is a really common pattern in software.</p>

<p>Since most ETL jobs like this are quite simple, let’s make a trivial example slightly more realistic by trying to automatically infer the database schema automatically. Let’s also try to make it fast enough to be usable for files with a few million rows in it.</p>

<p>An overview of the approach that we will follow is:</p>

<ol>
  <li>
    <p><strong>Group CSVs by directory</strong>, such that each directory corresponds to a SQL table that we would like to create.</p>
  </li>
  <li>
    <p><strong>Scan the the directory tree</strong> to create a list of CSV files we want to scan.</p>
  </li>
  <li>
    <p><strong>Autodetect the data type of each column</strong> across all files in each directory, and store the schema just outside the directory, so that it can be modified as needed.</p>
  </li>
  <li>
    <p><strong>Create the table from the autodetected schema</strong>.</p>
  </li>
  <li>
    <p><strong>Load the CSV files into SQL tables</strong>.</p>
  </li>
</ol>

<p>In past articles, we discussed how to <a href="../loading-csvs-in-clojure">read in CSVs</a> and <a href="../docker-postgres">create a postgres database with docker</a>. I’ll just assume that you read those already, that you have a Postgres instance running in docker already, so that we can get on with the ETL-specific code.</p>

<h2 id="group-csvs-in-directories">1. Group CSVs in Directories</h2>

<p>Let’s go get some census data from 2010 and download some data. The <a href="http://census.ire.org/data/bulkdata.html">census.ire.org</a> website has a handy tool that let’s you download census data on each state. Since this is an example, we will only use five states’ worth of data.</p>

<ol>
  <li><a href="http://censusdata.ire.org/01/all_060_in_01.P1.csv">Alabama</a></li>
  <li><a href="http://censusdata.ire.org/02/all_060_in_02.P1.csv">Alaska</a></li>
  <li><a href="http://censusdata.ire.org/04/all_060_in_04.P1.csv">Arizona</a></li>
  <li><a href="http://censusdata.ire.org/05/all_060_in_05.P1.csv">Arkansas</a></li>
  <li><a href="http://censusdata.ire.org/06/all_060_in_06.P1.csv">California</a></li>
</ol>

<p>Just making one table from a few small CSVs isn’t going to fully demonstrate this example, so let’s also fetch a much bigger dataset…the past 15 years of crime reports from Los Angeles, courtesy of <a href="https://data.gov">data.gov</a>.</p>

<ol>
  <li><a href="https://data.lacity.org/api/views/y8tr-7khq/rows.csv?accessType=DOWNLOAD">“Crime Data from 2010 to Present”</a></li>
</ol>

<p>Note that this file is MUCH larger than the census data; it is 6.8 million lines long, and has about 20 columns, and is 1.5G in size. It will be a better benchmark of performance than those short census files.</p>

<p>Now place all the files in a directory tree like this:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sqlcsv/
├── census
│   ├── all_060_in_01.P1.csv
│   ├── all_060_in_02.P1.csv
│   ├── all_060_in_04.P1.csv
│   ├── all_060_in_05.P1.csv
│   └── all_060_in_06.P1.csv
└── crimes
    └── Crimes_-_2001_to_present.csv
</code></pre>
</div>

<h2 id="scan-directories">2. Scan directories</h2>

<p>This is pretty easy using <code class="highlighter-rouge">file-seq</code>. All we have to do is create a few functions for listing files and subdirectories.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">net.roboloco.files</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">java-time</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jt</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">clojure.java.io</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jio</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">list-files</span><span class="w">
  </span><span class="s">"Lists only the files in the directory string DIR."</span><span class="w">
  </span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">file-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/file</span><span class="w"> </span><span class="n">dir</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">.isDirectory</span><span class="w"> </span><span class="o">^</span><span class="n">java.io.File</span><span class="w"> </span><span class="n">%</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">list-subdirectories</span><span class="w">
  </span><span class="s">"Lists only the subdirectorys of the directory string DIR"</span><span class="w">
  </span><span class="p">[</span><span class="n">dir</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">file-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/file</span><span class="w"> </span><span class="n">dir</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">.isDirectory</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/file</span><span class="w"> </span><span class="n">dir</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">has-suffix?</span><span class="w">
  </span><span class="s">"Works on file object types."</span><span class="w">
  </span><span class="p">[</span><span class="w"> </span><span class="o">^</span><span class="n">String</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="o">^</span><span class="n">java.io.File</span><span class="w"> </span><span class="n">file</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">.isFile</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="p">(</span><span class="nb">re-pattern</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">".*\\."</span><span class="w"> </span><span class="n">suffix</span><span class="w"> </span><span class="s">"$"</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">.getName</span><span class="w"> </span><span class="n">file</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">list-files-of-type</span><span class="w"> 
  </span><span class="s">"Lists all files in the directory with the extension ext."</span><span class="w">
  </span><span class="p">[</span><span class="n">dir</span><span class="w"> </span><span class="n">ext</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">file-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/file</span><span class="w"> </span><span class="n">dir</span><span class="p">))</span><span class="w">
       </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">has-suffix?</span><span class="w"> </span><span class="n">ext</span><span class="p">))))</span><span class="w">
</span></code></pre>
</div>

<p>Some string-cleaning utility functions will also come in handy:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">net.roboloco.util</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">alphanumeric?</span><span class="w">
  </span><span class="s">"TRUE when the string is completely alphanumeric."</span><span class="w">
  </span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nb">re-seq</span><span class="w"> </span><span class="o">#</span><span class="s">"[a-z_A-Z0-9]"</span><span class="w"> </span><span class="n">string</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">spaces-to-underscores</span><span class="w">
  </span><span class="s">"Converts spaces to underscores."</span><span class="w">
  </span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">#</span><span class="s">"\s"</span><span class="w"> </span><span class="s">"_"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">periods-to-underscores</span><span class="w">
  </span><span class="s">"Converts spaces to underscores."</span><span class="w">
  </span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="o">#</span><span class="s">"\."</span><span class="w"> </span><span class="s">"_"</span><span class="p">))</span><span class="w">
</span></code></pre>
</div>

<p>We’ll also need some simple date-parsing functions:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">net.roboloco.dates</span><span class="w">
  </span><span class="s">"Code for handling strings reperesnting dates and datetimes."</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">java-time</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">jt</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse-date</span><span class="w">
  </span><span class="s">"Parses a standard date, like 2019-02-17."</span><span class="w">
  </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jt/local-date</span><span class="w"> </span><span class="s">"yyyy-MM-dd"</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse-datetime</span><span class="w">
  </span><span class="s">"Returns the datetime format that Python's pandas usually saves in."</span><span class="w">
  </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">jt/local-date-time</span><span class="w"> </span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">local-to-offset</span><span class="w">
  </span><span class="s">"Converts a local date time to an offset date time. By default, it assumes
  that the local time is UTC, but you may change this with optional arg TZ."</span><span class="w">
  </span><span class="p">[</span><span class="n">local-date-time</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">tz</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">tz</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">tz</span><span class="w"> </span><span class="s">"UTC"</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">local-date-time</span><span class="w">
        </span><span class="p">(</span><span class="nf">jt/zoned-date-time</span><span class="w"> </span><span class="n">tz</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">jt/offset-date-time</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse-RFC3339</span><span class="w">
  </span><span class="s">"Assuming a UTC datestamp with T and Z separator, for example:
  2019-01-17T22:03:16Z
  2019-01-17T22:03:16.383Z
  2019-01-17T22:03:16.111222333Z"</span><span class="w">
  </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">local-to-offset</span><span class="w">
   </span><span class="p">(</span><span class="nf">condp</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">
     </span><span class="mi">20</span><span class="w"> </span><span class="p">(</span><span class="nf">jt/local-date-time</span><span class="w"> </span><span class="s">"yyyy-MM-dd'T'HH:mm:ss'Z'"</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">
     </span><span class="mi">24</span><span class="w"> </span><span class="p">(</span><span class="nf">jt/local-date-time</span><span class="w"> </span><span class="s">"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">
     </span><span class="mi">27</span><span class="w"> </span><span class="p">(</span><span class="nf">jt/local-date-time</span><span class="w"> </span><span class="s">"yyyy-MM-dd'T'HH:mm:ss.SSSSSS'Z'"</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">
     </span><span class="mi">30</span><span class="w"> </span><span class="p">(</span><span class="nf">jt/local-date-time</span><span class="w"> </span><span class="s">"yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'"</span><span class="w"> </span><span class="n">s</span><span class="p">))))</span><span class="w">

</span></code></pre>
</div>

<h2 id="autodetect-the-schema">3. Autodetect the Schema</h2>

<p>This is by far the most complex section of the program. For each element, the autodetector tests each of the parsing functions in <code class="highlighter-rouge">sql-types-and-parsers</code>, and the first that works will be is considered the inferred SQL type. As I experimented with this at the REPL, I realized that testing every sql parser on every element was prohibitively slow, so I defined <code class="highlighter-rouge">guess-all-sql-types-in-column</code> to reduce the rate of failed tests by remembering which parser last worked for each column.</p>

<p>Another note on optimization: although I initially assumed that I could make the CSV loading faster by scanning only the first N lines of each file, this ended up being error-prone in general, so I relented and allowed it to scan the whole file.</p>

<p>Note that this code only works for integers, floats, dates, datetimes, and strings (text), but that you could easily extend it by adding more things to <code class="highlighter-rouge">type-definitions</code>.  An exception thrown if types do not match in different files.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">net.roboloco.guess-schema</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.data.csv</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">net.roboloco.dates</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">dates</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">net.roboloco.files</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">files</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">net.roboloco.util</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">util</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:dynamic</span><span class="w"> </span><span class="n">*sql-types-and-parsers*</span><span class="w">
  </span><span class="c1">;; This data structure defines all of the SQL data types, and the appropriate
</span><span class="w">  </span><span class="c1">;; function to use when parsing a string containing that data type.
</span><span class="w">  </span><span class="c1">;; Parsers will be tried in sequential order, and the first one that works is used.
</span><span class="w">  </span><span class="c1">;; 
</span><span class="w">  </span><span class="c1">;; SQL               String-&gt;CLJ Parser
</span><span class="w">  </span><span class="p">[[</span><span class="s">"NULL"</span><span class="w">             </span><span class="o">#</span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">%</span><span class="p">))]</span><span class="w">
   </span><span class="p">[</span><span class="s">"INTEGER"</span><span class="w">          </span><span class="o">#</span><span class="p">(</span><span class="nf">Integer/parseInt</span><span class="w"> </span><span class="n">%</span><span class="p">)]</span><span class="w">
   </span><span class="p">[</span><span class="s">"DOUBLE PRECISION"</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">Float/parseFloat</span><span class="w"> </span><span class="n">%</span><span class="p">)]</span><span class="w">
   </span><span class="p">[</span><span class="s">"DATE"</span><span class="w">             </span><span class="n">dates/parse-date</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="s">"TIMESTAMPTZ"</span><span class="w">      </span><span class="n">dates/parse-RFC3339</span><span class="p">]</span><span class="w">
   </span><span class="p">[</span><span class="s">"TEXT"</span><span class="w">             </span><span class="o">#</span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">%</span><span class="p">)]])</span><span class="w"> </span><span class="c1">;; this is always true, so is the "default" value
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">guess-sql-parser</span><span class="w">
  </span><span class="s">"Given an unknown string, this fn runs through all of the SQL types &amp; parsers in 
  sql-types-and-parsers and returns the first row with a working parser."</span><span class="w">
  </span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">types-and-parsers</span><span class="w"> </span><span class="n">*sql-types-and-parsers*</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-let</span><span class="w"> </span><span class="p">[[</span><span class="n">sql-type</span><span class="w"> </span><span class="n">parse-fn</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">typerow</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">types-and-parsers</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-fn</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w">
               </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">false</span><span class="p">))</span><span class="w">
        </span><span class="n">typerow</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="n">types-and-parsers</span><span class="p">))))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">guess-all-sql-types-in-column</span><span class="w">
  </span><span class="s">"Like guess-sql-type, but an optimized version for looking at a whole column.
  In practice, this really reduces the number of tests and exceptions trapped
  over the simpler but much slower solution: 
         (set (flatten (map guess-sql-parser seq-of-strings)))"</span><span class="w">
  </span><span class="p">[</span><span class="n">seq-of-strings</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">strings</span><span class="w"> </span><span class="n">seq-of-strings</span><span class="w">
         </span><span class="n">last-successful-parse-fn</span><span class="w"> </span><span class="n">nil</span><span class="w">
         </span><span class="n">types-found</span><span class="w"> </span><span class="o">#</span><span class="p">{}]</span><span class="w">
    </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">strings</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">last-successful-parse-fn</span><span class="w"> </span><span class="n">string</span><span class="p">)</span><span class="w">
               </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">false</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span><span class="w">  </span><span class="c1">; Previously successful parser worked again
</span><span class="w">               </span><span class="n">last-successful-parse-fn</span><span class="w">
               </span><span class="n">types-found</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[[</span><span class="n">sql-type</span><span class="w"> </span><span class="n">parse-fn</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">guess-sql-parser</span><span class="w"> </span><span class="n">string</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span><span class="w">  </span><span class="c1">; A new working parser was found
</span><span class="w">                 </span><span class="n">parse-fn</span><span class="w">
                 </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">types-found</span><span class="w"> </span><span class="n">sql-type</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nb">next</span><span class="w"> </span><span class="n">strings</span><span class="p">)</span><span class="w">  </span><span class="c1">; No working parser found, move to next string
</span><span class="w">                 </span><span class="n">last-successful-parse-fn</span><span class="w">
                 </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">types-found</span><span class="w"> </span><span class="n">nil</span><span class="p">))))</span><span class="w">
      </span><span class="n">types-found</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">clean-column-names</span><span class="w">
  </span><span class="s">"Replaces whitespaces and periods in column names with underscores."</span><span class="w">
  </span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">columns</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">util/periods-to-underscores</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="n">util/spaces-to-underscores</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">guess-csv-column-types</span><span class="w">
  </span><span class="s">"Returns a map of column name to the guessed SQL column type. Reads every
  row in the CSV, and returns all types found for each column. Works in 
  parallel and lazily on chunks of 1000 lines, to reduce the time to parse
  very large files."</span><span class="w">
  </span><span class="p">[</span><span class="n">csv-filepath</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Scanning:"</span><span class="w"> </span><span class="n">csv-filepath</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">reader</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/reader</span><span class="w"> </span><span class="n">csv-filepath</span><span class="p">)]</span><span class="w">
     </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">rows</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.data.csv/read-csv</span><span class="w"> </span><span class="n">reader</span><span class="p">)</span><span class="w">
           </span><span class="n">header</span><span class="w"> </span><span class="p">(</span><span class="nf">clean-column-names</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">rows</span><span class="p">))</span><span class="w">
           </span><span class="n">data-rows</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">rows</span><span class="p">)</span><span class="w">
           </span><span class="n">chunk-size</span><span class="w"> </span><span class="mi">10000</span><span class="p">]</span><span class="w">
       </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">data-rows</span><span class="w">          
            </span><span class="p">(</span><span class="nf">partition-all</span><span class="w"> </span><span class="n">chunk-size</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">vector</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="c1">;; Convert list of rows into list of columns
</span><span class="w">            </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">pmap</span><span class="w"> </span><span class="n">guess-all-sql-types-in-column</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w">
            </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">10000</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="s">"rows scanned"</span><span class="p">)</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">range</span><span class="p">))</span><span class="w">
            </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="n">clojure.set/union</span><span class="w"> </span><span class="n">args</span><span class="p">)))</span><span class="w">
            </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">vector</span><span class="w"> </span><span class="n">header</span><span class="p">)</span><span class="w">
            </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{})))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">scan-csvdir-and-make-schema</span><span class="w">
  </span><span class="s">"Scans the header of every .csv file in CSVDIR, and returns a hashmap
  containing the schema of all the columns in the directory.
  If a non-alphanumeric string is found, raises an exception. 
  If the schema is inconsistent, raises an exception."</span><span class="w">
  </span><span class="p">[</span><span class="n">csvdir</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">csv-schemas</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">files/list-files-of-type</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="s">"csv"</span><span class="p">)</span><span class="w">
                         </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">guess-csv-column-types</span><span class="p">))</span><span class="w">
        </span><span class="n">columns</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="p">(</span><span class="nf">flatten</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">keys</span><span class="w"> </span><span class="n">csv-schemas</span><span class="p">)))</span><span class="w">
        </span><span class="n">problematic-columns</span><span class="w"> </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="n">util/alphanumeric?</span><span class="w"> </span><span class="n">columns</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">problematic-columns</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">Exception.</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Non-alphanumeric characters found in column names:"</span><span class="w">
                              </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">interpose</span><span class="w"> </span><span class="s">", "</span><span class="w">  </span><span class="n">problematic-columns</span><span class="p">))))))</span><span class="w">
    </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="n">columns</span><span class="p">]</span><span class="w">
               </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">all-types-for-col</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">col</span><span class="p">))</span><span class="w"> </span><span class="n">csv-schemas</span><span class="p">)</span><span class="w">
                                            </span><span class="p">(</span><span class="nf">flatten</span><span class="p">)</span><span class="w">
                                            </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="nb">nil?</span><span class="p">)</span><span class="w">
                                            </span><span class="p">(</span><span class="nb">set</span><span class="p">))</span><span class="w">
                     </span><span class="n">nullable-suffix</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">all-types-for-col</span><span class="w"> </span><span class="s">"NULL"</span><span class="p">)</span><span class="w"> 
                                       </span><span class="s">" NULL"</span><span class="w">
                                       </span><span class="s">""</span><span class="p">)</span><span class="w">
                     </span><span class="n">types</span><span class="w"> </span><span class="p">(</span><span class="nb">disj</span><span class="w"> </span><span class="n">all-types-for-col</span><span class="w"> </span><span class="s">"NULL"</span><span class="p">)]</span><span class="w">
                 </span><span class="p">(</span><span class="k">cond</span><span class="w">
                  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">types</span><span class="p">))</span><span class="w">        </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="n">nil</span><span class="p">]</span><span class="w">
                  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">types</span><span class="p">))</span><span class="w">        </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">types</span><span class="p">)</span><span class="w"> </span><span class="n">nullable-suffix</span><span class="p">)]</span><span class="w">
                  </span><span class="c1">;; If it's mixed integer and float, make everything float
</span><span class="w">                  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="s">"INTEGER"</span><span class="w"> </span><span class="s">"DOUBLE PRECISION"</span><span class="p">}</span><span class="w"> </span><span class="n">types</span><span class="p">)</span><span class="w"> 
                                             </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"DOUBLE PRECISION"</span><span class="w"> </span><span class="n">nullable-suffix</span><span class="p">)]</span><span class="w">
                  </span><span class="c1">;; If the default type of TEXT is in there, choose text
</span><span class="w">                  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">types</span><span class="w"> </span><span class="s">"TEXT"</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="n">col</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"TEXT"</span><span class="w"> </span><span class="n">nullable-suffix</span><span class="p">)]</span><span class="w">
                  </span><span class="no">:otherwise</span><span class="w">  </span><span class="c1">;; Otherwise we have some weird error
</span><span class="w">                  </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">Exception.</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Inconsistent types across files for column: "</span><span class="w"> 
                                           </span><span class="n">col</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="n">types</span><span class="p">))))))))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse-csv-rows-using-schema</span><span class="w">
  </span><span class="s">"Lazily parse CSV-ROWS using the schema."</span><span class="w">
  </span><span class="p">[</span><span class="n">schema</span><span class="w"> </span><span class="n">csv-rows</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">header</span><span class="w"> </span><span class="p">(</span><span class="nf">clean-column-names</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">csv-rows</span><span class="p">))</span><span class="w">
        </span><span class="n">types</span><span class="w">  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">header</span><span class="p">)</span><span class="w">
        </span><span class="n">empty-string-to-nil</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="n">s</span><span class="p">))</span><span class="w">
        </span><span class="n">raw-rows</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">empty-string-to-nil</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">csv-rows</span><span class="p">))</span><span class="w">
        </span><span class="n">all-parsers</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">*sql-types-and-parsers*</span><span class="p">)</span><span class="w">
        </span><span class="n">row-parsers</span><span class="w"> </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">all-parsers</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">types</span><span class="p">)</span><span class="w">
        </span><span class="n">typed-rows</span><span class="w"> </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">raw-row</span><span class="w"> </span><span class="n">raw-rows</span><span class="p">]</span><span class="w">
                     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">parse-fn</span><span class="w"> </span><span class="n">element</span><span class="p">]</span><span class="w">
                            </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">parse-fn</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">element</span><span class="p">)))</span><span class="w">
                              </span><span class="p">(</span><span class="nf">try</span><span class="w"> </span><span class="p">(</span><span class="nf">parse-fn</span><span class="w"> </span><span class="n">element</span><span class="p">)</span><span class="w">
                                   </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
                                     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Schema:"</span><span class="w"> </span><span class="n">schema</span><span class="p">)</span><span class="w">
                                     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Header:"</span><span class="w"> </span><span class="n">header</span><span class="p">)</span><span class="w">
                                     </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Raw row:"</span><span class="w"> </span><span class="n">raw-row</span><span class="p">)</span><span class="w">
                                     </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="n">e</span><span class="p">)))))</span><span class="w">
                          </span><span class="n">row-parsers</span><span class="w">
                          </span><span class="n">raw-row</span><span class="p">))</span><span class="w">
        </span><span class="n">cnt</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="n">chunk-size</span><span class="w"> </span><span class="mi">1000</span><span class="p">]</span><span class="w">
    </span><span class="p">[</span><span class="n">header</span><span class="w"> </span><span class="n">typed-rows</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">table-definition-sql-string</span><span class="w">
  </span><span class="s">"Returns a string suitable for creating a SQL table named TABLE-NAME, given
  a hashmap SCHEMA of column names to column types. The ENDING-STRING is appended
  to the end of the create table statement, if needed. "</span><span class="w">
  </span><span class="p">[</span><span class="n">table-name</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">ending-string</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ending-string</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">ending-string</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
        </span><span class="n">col-defs</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">schema</span><span class="w">
                      </span><span class="p">(</span><span class="nb">sort-by</span><span class="w"> </span><span class="nb">first</span><span class="p">)</span><span class="w">
                      </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="nb">nil?</span><span class="w"> </span><span class="nb">second</span><span class="p">))</span><span class="w">
                      </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[[</span><span class="n">col</span><span class="w"> </span><span class="n">type</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"\t%s %s"</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="n">type</span><span class="p">)))</span><span class="w">
                      </span><span class="p">(</span><span class="nf">interpose</span><span class="w"> </span><span class="s">",\n"</span><span class="p">)</span><span class="w">
                      </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"CREATE TABLE %s (\n%s %s\n);"</span><span class="w">
            </span><span class="n">table-name</span><span class="w"> </span><span class="n">col-defs</span><span class="w"> </span><span class="n">ending-string</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>We are now ready to actually do the autodetection! Let’s create our main namespace:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">net.roboloco.csv2sql</span><span class="w">
  </span><span class="p">(</span><span class="no">:gen-class</span><span class="p">)</span><span class="w">
  </span><span class="p">(</span><span class="no">:require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure.data.csv</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">clojure.java.jdbc</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">sql</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">net.roboloco.guess-schema</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">guess</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">net.roboloco.files</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">files</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="nf">set!</span><span class="w"> </span><span class="n">*warn-on-reflection*</span><span class="w"> </span><span class="n">true</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">table-schema-filename</span><span class="w"> </span><span class="p">[</span><span class="n">dirname</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s-schema.edn"</span><span class="w"> </span><span class="n">dirname</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">table-sql-filename</span><span class="w"> </span><span class="p">[</span><span class="n">dirname</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"%s.sql"</span><span class="w"> </span><span class="n">dirname</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">autodetect-sql-schemas!</span><span class="w">
  </span><span class="s">"Scans through the subdirectories of CSVDIR, infers the column data types,
  and stores the inferred schema in CSVDIR so that you may manually edit it
  before loading it in with MAKE-SQL-TABLES."</span><span class="w">
  </span><span class="p">[</span><span class="n">csvdir</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">dir</span><span class="w"> </span><span class="p">(</span><span class="nf">files/list-subdirectories</span><span class="w"> </span><span class="n">csvdir</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">printf</span><span class="w"> </span><span class="s">"Autodetecting schema for: %s\n"</span><span class="w"> </span><span class="n">dir</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">tablename</span><span class="w"> </span><span class="p">(</span><span class="nf">.getName</span><span class="w"> </span><span class="o">^</span><span class="n">java.io.File</span><span class="w"> </span><span class="n">dir</span><span class="p">)</span><span class="w">
          </span><span class="n">schema</span><span class="w"> </span><span class="p">(</span><span class="nf">guess/scan-csvdir-and-make-schema</span><span class="w"> </span><span class="n">dir</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">schema</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">table-sql</span><span class="w"> </span><span class="p">(</span><span class="nf">guess/table-definition-sql-string</span><span class="w"> </span><span class="n">tablename</span><span class="w"> </span><span class="n">schema</span><span class="p">)]</span><span class="w">
          </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="p">(</span><span class="nf">table-schema-filename</span><span class="w"> </span><span class="n">tablename</span><span class="p">))</span><span class="w"> </span><span class="n">schema</span><span class="p">)</span><span class="w">          
          </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="p">(</span><span class="nf">table-schema-filename</span><span class="w"> </span><span class="n">tablename</span><span class="p">))</span><span class="w"> </span><span class="n">schema</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">spit</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="p">(</span><span class="nf">table-sql-filename</span><span class="w"> </span><span class="n">tablename</span><span class="p">))</span><span class="w"> </span><span class="n">table-sql</span><span class="p">))))))</span><span class="w">
</span></code></pre>
</div>

<p>You may note that I’m storing the SQL schemas for each subdirectory in the root <code class="highlighter-rouge">sqlcsv/</code> directory. This will let you hand-tune the schema as needed, if you want to make an index on one key or another, or make a particular column unique and required.</p>

<h2 id="create-the-autodetected-schema">4. Create the Autodetected Schema</h2>

<p>With the schema autodetected, we now need to create the tables. Continuing along with the <code class="highlighter-rouge">net.roboloco.csv2sql</code> namespace, and assuming that you are using the same <a href="../docker-postgres">postgres database</a> from a previous article:</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">default-db</span><span class="w"> </span><span class="p">{</span><span class="no">:dbtype</span><span class="w"> </span><span class="s">"postgresql"</span><span class="w"> 
                 </span><span class="no">:dbname</span><span class="w">   </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"POSTGERS_DB"</span><span class="p">)</span><span class="w">  </span><span class="s">"csv2sql"</span><span class="p">)</span><span class="w">
                 </span><span class="no">:user</span><span class="w">     </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"POSTGRES_USER"</span><span class="p">)</span><span class="w"> </span><span class="s">"postgres"</span><span class="p">)</span><span class="w">
                 </span><span class="no">:password</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"POSTGRES_PASS"</span><span class="p">)</span><span class="w"> </span><span class="s">"mysecretpassword"</span><span class="p">)})</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">connection-ok?</span><span class="w">
  </span><span class="s">"A predicate that tests if the database is connected."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">{</span><span class="no">:result</span><span class="w"> </span><span class="mi">15</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">sql/query</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="p">[</span><span class="s">"select 3*5 as result"</span><span class="p">]))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">drop-existing-sql-tables!</span><span class="w">
  </span><span class="s">"For each subdirectory in DIRNAME, drop any tables with the same name."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">csvdir</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">table-name</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">.getName</span><span class="w"> </span><span class="o">^</span><span class="n">java.io.File</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w">
                          </span><span class="p">(</span><span class="nf">files/list-subdirectories</span><span class="w"> </span><span class="n">csvdir</span><span class="p">))]</span><span class="w">    
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cmd</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"DROP TABLE IF EXISTS %s;"</span><span class="w"> </span><span class="n">table-name</span><span class="p">)</span><span class="w"> </span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nf">sql/db-do-commands</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">cmd</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-sql-tables!</span><span class="w">
  </span><span class="s">"Makes the SQL tables from whatever is in the database. "</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">csvdir</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">sql-file</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">.getName</span><span class="w"> </span><span class="o">^</span><span class="n">java.io.File</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> 
                        </span><span class="p">(</span><span class="nf">files/list-files-of-type</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="s">"sql"</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">table-sql</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="n">sql-file</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">table-sql</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">sql/db-do-commands</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">table-sql</span><span class="p">))))</span><span class="w">

</span></code></pre>
</div>

<h2 id="load-the-csv-files-into-sql">5. Load the CSV files into SQL</h2>

<p>The final step is to load in the CSV file. As we do so, we need to parse the strings from the CSV using the schema so that they are converted into the proper data type for JDBC to properly insert them in Postgres.</p>

<div class="language-clojure highlighter-rouge"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">insert-csv!</span><span class="w">
  </span><span class="s">"Inserts the rows of the CSV into the database, converting the rows to the appropriate
  type as they are loaded. Lazy, so it works on very large files. If a column is not
  found in the schema, it is omitted and not inserted into the database. "</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">csvfile</span><span class="w"> </span><span class="n">schema</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">reader</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/reader</span><span class="w"> </span><span class="n">csvfile</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">csv-rows</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.data.csv/read-csv</span><span class="w"> </span><span class="n">reader</span><span class="p">)</span><span class="w">
          </span><span class="p">[</span><span class="n">header</span><span class="w"> </span><span class="n">typed-rows</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">guess/parse-csv-rows-using-schema</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">csv-rows</span><span class="p">)</span><span class="w">
          </span><span class="n">cnt</span><span class="w"> </span><span class="p">(</span><span class="nf">atom</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
          </span><span class="n">chunk-size</span><span class="w"> </span><span class="mi">1000</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">chunk-of-rows</span><span class="w"> </span><span class="p">(</span><span class="nf">partition-all</span><span class="w"> </span><span class="n">chunk-size</span><span class="w"> </span><span class="n">typed-rows</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">line-num</span><span class="w"> </span><span class="p">(</span><span class="nf">swap!</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="nb">inc</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Inserted"</span><span class="w">  </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">chunk-size</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="err">@</span><span class="n">cnt</span><span class="p">))</span><span class="w"> </span><span class="s">"rows"</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="nf">sql/insert-multi!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">header</span><span class="w"> </span><span class="n">chunk-of-rows</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">insert-all-csvs!</span><span class="w">
  </span><span class="s">"Loads all the subdirectories of CSVDIR as tables. Optional hashmap MANUAL-OPTIONS
  lets you decide how to customize various tables; for example, you may want to set
  an optional table."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">csvdir</span><span class="p">]</span><span class="w">  
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">dirname</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">.getName</span><span class="w"> </span><span class="o">^</span><span class="n">java.io.File</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w">
                       </span><span class="p">(</span><span class="nf">files/list-subdirectories</span><span class="w"> </span><span class="n">csvdir</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">filepath</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="p">(</span><span class="nf">table-schema-filename</span><span class="w"> </span><span class="n">dirname</span><span class="p">))</span><span class="w">
          </span><span class="n">_</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="n">filepath</span><span class="p">)</span><span class="w">
          </span><span class="n">schema</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="n">filepath</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">empty?</span><span class="w"> </span><span class="n">schema</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">files/list-files-of-type</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="n">csvdir</span><span class="w"> </span><span class="s">"/"</span><span class="w"> </span><span class="n">dirname</span><span class="p">)</span><span class="w"> </span><span class="s">"csv"</span><span class="p">)</span><span class="w">
             </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">csvfile</span><span class="p">]</span><span class="w">
                    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">format</span><span class="w"> </span><span class="s">"Loading: %s"</span><span class="w"> </span><span class="n">csvfile</span><span class="p">))</span><span class="w">
                    </span><span class="p">(</span><span class="nf">insert-csv!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">dirname</span><span class="w"> </span><span class="n">csvfile</span><span class="w"> </span><span class="n">schema</span><span class="p">)))</span><span class="w">
             </span><span class="nb">doall</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-main</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">csvdir</span><span class="w"> </span><span class="p">(</span><span class="nf">System/getenv</span><span class="w"> </span><span class="s">"CSVDIR"</span><span class="p">)</span><span class="w">
        </span><span class="n">db</span><span class="w"> </span><span class="n">default-db</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">when-not</span><span class="w"> </span><span class="p">(</span><span class="nf">connection-ok?</span><span class="w"> </span><span class="n">db</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">Exception.</span><span class="w"> </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="s">"Unable to connect to DB:"</span><span class="w"> </span><span class="n">db</span><span class="p">))))</span><span class="w">
    </span><span class="p">(</span><span class="nf">autodetect-sql-schemas!</span><span class="w"> </span><span class="n">csvdir</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">make-sql-tables!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">csvdir</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">insert-all-csvs!</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">csvdir</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"Done!"</span><span class="p">)))</span><span class="w">
</span></code></pre>
</div>

<p>Nothing left to do but try it out! The final step is to run <code class="highlighter-rouge">(-main)</code> either at the REPL or add <code class="highlighter-rouge">gen-class</code> to the namespace and build an uberjar with <code class="highlighter-rouge">(-main)</code> set as the entry point (in <code class="highlighter-rouge">project.clj</code>), and then launch it with an environment variable that sets the CSVDIR:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>lein uberjar

CSVDIR=/path/to/your/sqlcsv/ java -jar target/csv2sql-0.1.0-SNAPSHOT-standalone.jar
</code></pre>
</div>

<h2 id="conclusion">Conclusion</h2>

<p>The above is probably sufficient for this exercise – this ETL job will populate a database with a few million rows in a few minutes. On my laptop, it ingests about 5000-10000 rows per second, depending on the CSV.</p>

<p>Not bad a couple hundred lines of code, but it could probably still be trimmed/simplified. The above code may be found in the <a href="https://github.com/ivarthorson/csv2sql">csv2sql repo</a> if you want to go further.</p>

<p>Some possible extensions to this would be:</p>

<ol>
  <li>
    <p>Warn the user if 99.9% of the elements of a column are of one type, but there are a few values that are of a different type.</p>
  </li>
  <li>
    <p>Add support for JSONs, rather than just CSVs. This would probably involve flattening nested JSONs so that <code class="highlighter-rouge"><span class="p">{</span><span class="nt">"a"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">"b"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">}}</span></code> would become <code class="highlighter-rouge"><span class="p">{</span><span class="nt">"a.b"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">}</span></code>, and might involve generalizing the loader.</p>
  </li>
  <li>
    <p>If your database supports tens or hundreds of millions of rows, add support for Parquet files, a common tabular data format for big data.</p>
  </li>
</ol>

<p>This little program was focused on ETL, and we should probably stop at that. Rather than bolt on a HTTP CRUD API here, it might make more sense to contain that functionality as a separate app.</p>

<h2 id="references">References</h2>

<ol>
  <li><a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/using_sql.html">http://clojure-doc.org/articles/ecosystem/java_jdbc/using_sql.html</a></li>
  <li><a href="https://docs.timescale.com/v1.2/using-timescaledb/writing-data">https://docs.timescale.com/v1.2/using-timescaledb/writing-data</a></li>
</ol>

        
      </div><!-- /.entry-content -->
    </div><!-- /.entry-wrapper -->
    <nav class="pagination" role="navigation">
      
        <a href="/blog/composite-robot-construction/" class="btn" title="Composite Robot Construction">Previous</a>
      
      
        <a href="/blog/jupyter-quick-install/" class="btn" title="Jupyter Quick Install for Scientists">Next</a>
      
    </nav><!-- /.pagination -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo" class="entry-wrapper">
    

<div>&copy; 2019 Ivar Thorson. </div>
<div class="legaltext">Powered by <a href="http://jekyllrb.com" rel="nofollow">Jekyll</a> using a modified version of the <a href="https://mademistakes.com/work/so-simple-jekyll-theme/" rel="nofollow">So Simple Theme</a>.</div>
<div class="social-icons">
	<a href="https://twitter.com/ivarthorson" title="Ivar Thorson on Twitter" target="_blank"><i class="fa fa-twitter-square fa-2x"></i></a>
	
	
	
	
	
	
	<a href="https://github.com/ivarthorson" title="Ivar Thorson on Github" target="_blank"><i class="fa fa-github-square fa-2x"></i></a>
	
  
	
  <a href="/feed.xml" title="Atom/RSS feed"><i class="fa fa-rss-square fa-2x"></i></a>
</div><!-- /.social-icons -->

  </footer>
</div><!-- /.footer-wrapper -->

<script type="text/javascript">
  var BASE_URL = '';
</script>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>




</body>
</html>
